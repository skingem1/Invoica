{
  "tasks": [
    {
      "id": "SDK-277",
      "agent": "backend-core",
      "type": "feature",
      "priority": "high",
      "status": "pending",
      "dependencies": [],
      "context": "Create sdk/typescript/src/array-utils.ts \u2014 array manipulation utilities.\n\nSTRICT: Max 40 lines. Pure functions. No dependencies. Full JSDoc with @param and @returns.\n\nExport these functions:\n\n1. unique<T>(array: T[]): T[]\n   - Return new array with duplicates removed (preserves order)\n   - Use Array.from(new Set(array))\n\n2. chunk<T>(array: T[], size: number): T[][]\n   - Split array into chunks of given size\n   - Last chunk may be smaller\n   - If size <= 0, return empty array\n   - Example: chunk([1,2,3,4,5], 2) => [[1,2],[3,4],[5]]\n\n3. flatten<T>(array: (T | T[])[]): T[]\n   - Flatten one level of nesting\n   - Example: flatten([[1,2],[3],[4,5]]) => [1,2,3,4,5]\n   - Non-array items pass through: flatten([1,[2,3]]) => [1,2,3]\n\n4. groupBy<T>(array: T[], key: keyof T | ((item: T) => string)): Record<string, T[]>\n   - Group array items by key or key function\n   - If key is a function, call it on each item\n   - If key is a property name, access item[key] and convert to string\n   - Example: groupBy([{a:'x',b:1},{a:'y',b:2},{a:'x',b:3}], 'a') => {x:[...],y:[...]}\n\n5. intersection<T>(a: T[], b: T[]): T[]\n   - Return elements present in both arrays\n   - Use Set for O(n) lookup\n   - Preserves order from first array\n\nExport: unique, chunk, flatten, groupBy, intersection\nKeep under 40 lines.",
      "deliverables": {
        "code": [
          "sdk/typescript/src/array-utils.ts"
        ]
      },
      "description": "Array manipulation utilities"
    },
    {
      "id": "SDK-278",
      "agent": "backend-core",
      "type": "test",
      "priority": "high",
      "status": "pending",
      "dependencies": [],
      "context": "Create sdk/typescript/src/__tests__/array-utils.test.ts \u2014 tests for array-utils.ts.\n\nImport: { unique, chunk, flatten, groupBy, intersection } from '../array-utils'\n\nTest cases (describe 'array-utils'):\n1. unique([1,2,2,3,3,3]) => [1,2,3]\n2. unique(['a','b','a']) => ['a','b']\n3. chunk([1,2,3,4,5], 2) => [[1,2],[3,4],[5]]\n4. chunk([1,2,3], 5) => [[1,2,3]]\n5. chunk([1,2], 0) => []\n6. flatten([[1,2],[3],[4,5]]) => [1,2,3,4,5]\n7. flatten([1,[2,3],4]) => [1,2,3,4]\n8. groupBy([{t:'a',v:1},{t:'b',v:2},{t:'a',v:3}], 't') groups correctly: expect result.a to have length 2, result.b length 1\n9. groupBy([1,2,3,4], (n) => n % 2 === 0 ? 'even' : 'odd') groups correctly\n10. intersection([1,2,3], [2,3,4]) => [2,3]\n11. intersection([1,2], [3,4]) => []\n12. intersection([], [1,2]) => []\n\nKeep tests 1-2 lines each. Max 35 lines total. Use Jest expect().",
      "deliverables": {
        "code": [
          "sdk/typescript/src/__tests__/array-utils.test.ts"
        ]
      },
      "description": "Tests for array-utils"
    },
    {
      "id": "SDK-279",
      "agent": "backend-core",
      "type": "feature",
      "priority": "high",
      "status": "pending",
      "dependencies": [],
      "context": "Create sdk/typescript/src/math-utils.ts \u2014 math helper utilities.\n\nSTRICT: Max 30 lines. Pure functions. No dependencies. Full JSDoc with @param and @returns.\n\nExport these functions:\n\n1. sum(numbers: number[]): number\n   - Return sum of all numbers. Empty array returns 0.\n\n2. average(numbers: number[]): number\n   - Return arithmetic mean. Empty array returns 0.\n\n3. median(numbers: number[]): number\n   - Return median value. Empty array returns 0.\n   - Sort a copy (don't mutate), return middle value or average of two middle values.\n\n4. roundTo(value: number, decimals: number): number\n   - Round to N decimal places\n   - Use Number(value.toFixed(decimals))\n\n5. lerp(start: number, end: number, t: number): number\n   - Linear interpolation: start + (end - start) * t\n   - t is 0-1 range (not clamped)\n\n6. percentage(value: number, total: number): number\n   - Calculate percentage: (value / total) * 100\n   - Return 0 if total is 0\n\nExport: sum, average, median, roundTo, lerp, percentage\nKeep under 30 lines.",
      "deliverables": {
        "code": [
          "sdk/typescript/src/math-utils.ts"
        ]
      },
      "description": "Math helper utilities"
    },
    {
      "id": "SDK-280",
      "agent": "backend-core",
      "type": "test",
      "priority": "high",
      "status": "pending",
      "dependencies": [],
      "context": "Create sdk/typescript/src/__tests__/math-utils.test.ts \u2014 tests for math-utils.ts.\n\nImport: { sum, average, median, roundTo, lerp, percentage } from '../math-utils'\n\nTest cases (describe 'math-utils'):\n1. sum([1,2,3]) => 6\n2. sum([]) => 0\n3. average([2,4,6]) => 4\n4. average([]) => 0\n5. median([1,2,3]) => 2\n6. median([1,2,3,4]) => 2.5\n7. median([]) => 0\n8. roundTo(3.14159, 2) => 3.14\n9. roundTo(3.145, 2) => 3.15\n10. lerp(0, 10, 0.5) => 5\n11. lerp(0, 10, 0) => 0\n12. lerp(0, 10, 1) => 10\n13. percentage(25, 100) => 25\n14. percentage(1, 3) to be close to 33.33 (use toBeCloseTo with 1 decimal)\n15. percentage(5, 0) => 0\n\nKeep tests 1-2 lines each. Max 35 lines total. Use Jest expect().",
      "deliverables": {
        "code": [
          "sdk/typescript/src/__tests__/math-utils.test.ts"
        ]
      },
      "description": "Tests for math-utils"
    },
    {
      "id": "FE-480",
      "agent": "frontend",
      "type": "test",
      "priority": "high",
      "status": "pending",
      "dependencies": [],
      "context": "Create frontend/hooks/__tests__/use-intersection-observer.test.ts \u2014 tests for use-intersection-observer.ts.\n\nImport: { renderHook, act } from '@testing-library/react'\nImport: { useIntersectionObserver } from '../use-intersection-observer'\n\nYou need to mock IntersectionObserver globally. Before all tests:\n\nlet mockObserve: jest.Mock;\nlet mockDisconnect: jest.Mock;\nlet mockCallback: (entries: Partial<IntersectionObserverEntry>[]) => void;\n\nbeforeEach(() => {\n  mockObserve = jest.fn();\n  mockDisconnect = jest.fn();\n  (global as any).IntersectionObserver = jest.fn((cb) => {\n    mockCallback = cb;\n    return { observe: mockObserve, disconnect: mockDisconnect, unobserve: jest.fn() };\n  });\n});\n\nTest cases (describe 'useIntersectionObserver'):\n1. 'returns initial state' \u2014 render hook, expect result.current.isIntersecting === false, result.current.entry === null\n2. 'ref is a function' \u2014 expect typeof result.current.ref === 'function'\n3. 'observes element when ref is set' \u2014 create a div, act(() => result.current.ref(div)), expect mockObserve to have been called\n4. 'disconnects on unmount' \u2014 create div, set ref, unmount, expect mockDisconnect to have been called\n5. 'updates isIntersecting when entry changes' \u2014 create div, set ref, then act(() => mockCallback([{ isIntersecting: true }])), expect result.current.isIntersecting === true\n\nMax 45 lines. Use Jest + React Testing Library.",
      "deliverables": {
        "code": [
          "frontend/hooks/__tests__/use-intersection-observer.test.ts"
        ]
      },
      "description": "Tests for use-intersection-observer hook"
    },
    {
      "id": "FE-481",
      "agent": "frontend",
      "type": "feature",
      "priority": "high",
      "status": "pending",
      "dependencies": [],
      "context": "Create frontend/components/Divider.tsx \u2014 a horizontal/vertical divider component.\n\nSTRICT: Max 30 lines. React 18+. Full JSDoc. Named export only.\n\nProps interface (MUST export):\n/** Props for Divider component */\nexport interface DividerProps {\n  /** Orientation of the divider */\n  orientation?: 'horizontal' | 'vertical';\n  /** Optional label text displayed in the center */\n  label?: string;\n  /** Additional CSS class */\n  className?: string;\n  /** CSS color for the divider line */\n  color?: string;\n  /** Thickness in pixels (default: 1) */\n  thickness?: number;\n  /** Spacing/margin in pixels (default: 16) */\n  spacing?: number;\n}\n\nRender:\n- Wrapper: <div role=\"separator\" className={`divider divider-{orientation} ${className || ''}`} style={...} aria-orientation={orientation}>\n- Horizontal: style={{ borderTop: `{thickness}px solid {color || '#e5e7eb'}`, margin: `{spacing}px 0` }}\n- Vertical: style={{ borderLeft: `{thickness}px solid {color || '#e5e7eb'}`, margin: `0 {spacing}px`, alignSelf: 'stretch' }}\n- If label provided: <div class=\"divider-label\" style={{display:'flex',alignItems:'center',gap:'8px'}}> with <span>{label}</span> between two <hr> elements styled with flex:1\n- Defaults: orientation='horizontal', thickness=1, spacing=16\n\nExport: DividerProps, Divider",
      "deliverables": {
        "code": [
          "frontend/components/Divider.tsx"
        ]
      },
      "description": "Horizontal/vertical divider component"
    },
    {
      "id": "FE-482",
      "agent": "frontend",
      "type": "test",
      "priority": "high",
      "status": "pending",
      "dependencies": [],
      "context": "Create frontend/components/__tests__/Divider.test.tsx \u2014 tests for Divider.tsx.\n\nImport: import { render, screen } from '@testing-library/react'\nImport: import { Divider } from '../Divider'\n\nTest cases (describe 'Divider'):\n1. 'renders horizontal divider by default' \u2014 render(<Divider />), expect role=\"separator\" in document\n2. 'has horizontal class by default' \u2014 render(<Divider />), expect element with class 'divider-horizontal'\n3. 'renders vertical orientation' \u2014 render(<Divider orientation=\"vertical\" />), expect class 'divider-vertical'\n4. 'sets aria-orientation' \u2014 render(<Divider orientation=\"vertical\" />), expect aria-orientation=\"vertical\"\n5. 'renders label when provided' \u2014 render(<Divider label=\"OR\" />), expect text \"OR\" in document\n6. 'applies custom className' \u2014 render(<Divider className=\"my-class\" />), expect element with class 'my-class'\n7. 'has divider base class' \u2014 render(<Divider />), expect element with class 'divider'\n\nMax 30 lines. Use Jest + React Testing Library. Each test 2-3 lines.",
      "deliverables": {
        "code": [
          "frontend/components/__tests__/Divider.test.tsx"
        ]
      },
      "description": "Tests for Divider component"
    },
    {
      "id": "SDK-281",
      "agent": "backend-core",
      "type": "feature",
      "priority": "medium",
      "status": "pending",
      "dependencies": [],
      "context": "Create sdk/typescript/src/retry-utils.ts \u2014 retry execution utilities.\n\nSTRICT: Max 35 lines. No external dependencies. Full JSDoc with @param and @returns.\n\nTypes to export:\nexport interface RetryOptions {\n  maxAttempts?: number;   // default 3\n  delay?: number;         // ms between retries, default 1000\n  backoff?: number;       // multiplier for delay each retry, default 1 (no backoff)\n  onRetry?: (error: Error, attempt: number) => void;  // optional callback\n}\n\nExport this function:\n\n1. retry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T>\n   - Execute fn(), if it throws, retry up to maxAttempts times\n   - Wait delay * (backoff ^ attempt) ms between retries using: new Promise(r => setTimeout(r, waitTime))\n   - Call onRetry callback if provided before each retry\n   - If all attempts fail, throw the last error\n   - Default: maxAttempts=3, delay=1000, backoff=1\n\nImplementation:\n- const { maxAttempts = 3, delay = 1000, backoff = 1, onRetry } = options || {}\n- Loop from 1 to maxAttempts:\n  - try { return await fn() }\n  - catch(e): if last attempt, throw e\n  - Call onRetry if exists\n  - await sleep(delay * Math.pow(backoff, attempt - 1))\n\nExport: RetryOptions, retry\nKeep under 35 lines.",
      "deliverables": {
        "code": [
          "sdk/typescript/src/retry-utils.ts"
        ]
      },
      "description": "Retry execution utilities"
    },
    {
      "id": "SDK-282",
      "agent": "backend-core",
      "type": "test",
      "priority": "medium",
      "status": "pending",
      "dependencies": [],
      "context": "Create sdk/typescript/src/__tests__/retry-utils.test.ts \u2014 tests for retry-utils.ts.\n\nImport: { retry } from '../retry-utils'\n\nUse jest.useFakeTimers() approach OR real async. Since retry uses setTimeout internally, use real timers with short delays.\n\nTest cases (describe 'retry-utils'):\n1. 'resolves on first success' \u2014 const fn = jest.fn().mockResolvedValue('ok'); result = await retry(fn, {delay:10}); expect(result).toBe('ok'); expect(fn).toHaveBeenCalledTimes(1)\n2. 'retries on failure then succeeds' \u2014 const fn = jest.fn().mockRejectedValueOnce(new Error('fail')).mockResolvedValue('ok'); result = await retry(fn, {delay:10}); expect(result).toBe('ok'); expect(fn).toHaveBeenCalledTimes(2)\n3. 'throws after max attempts' \u2014 const fn = jest.fn().mockRejectedValue(new Error('fail')); await expect(retry(fn, {maxAttempts:2, delay:10})).rejects.toThrow('fail'); expect(fn).toHaveBeenCalledTimes(2)\n4. 'calls onRetry callback' \u2014 const onRetry = jest.fn(); const fn = jest.fn().mockRejectedValueOnce(new Error('e')).mockResolvedValue('ok'); await retry(fn, {delay:10, onRetry}); expect(onRetry).toHaveBeenCalledTimes(1)\n5. 'uses default maxAttempts of 3' \u2014 const fn = jest.fn().mockRejectedValue(new Error('e')); await expect(retry(fn, {delay:10})).rejects.toThrow(); expect(fn).toHaveBeenCalledTimes(3)\n\nMax 30 lines. Use Jest expect(). Keep delay:10 for fast tests.",
      "deliverables": {
        "code": [
          "sdk/typescript/src/__tests__/retry-utils.test.ts"
        ]
      },
      "description": "Tests for retry-utils"
    }
  ]
}