{
  "tasks": [
    {
      "id": "BE-170",
      "agent": "backend-core",
      "type": "feature",
      "priority": "high",
      "status": "pending",
      "context": "Create a centralized error module for the Countable backend at backend/src/errors/index.ts. This module should export typed error classes that all API handlers can use for consistent error responses. Classes needed: (1) ApiError extends Error — base class with statusCode, code, and details fields. (2) ValidationError extends ApiError — 400 status, code 'VALIDATION_ERROR'. (3) NotFoundError extends ApiError — 404 status, code 'NOT_FOUND'. (4) AuthenticationError extends ApiError — 401 status, code 'UNAUTHORIZED'. (5) RateLimitError extends ApiError — 429 status, code 'RATE_LIMIT_EXCEEDED'. Each class constructor takes (message: string, details?: Record<string, unknown>). Export all classes as named exports. Use TypeScript strict mode. Keep it simple — no external dependencies.",
      "deliverables": {
        "code": [
          "backend/src/errors/index.ts"
        ],
        "tests": []
      },
      "description": "Create centralized error classes (ApiError, ValidationError, NotFoundError, AuthenticationError, RateLimitError) at backend/src/errors/index.ts. ~40 lines.",
      "constraints": "NEW file only. No external dependencies. Each class extends ApiError which extends Error. Export all as named exports. Keep under 50 lines."
    },
    {
      "id": "BE-171",
      "agent": "backend-core",
      "type": "feature",
      "priority": "medium",
      "status": "pending",
      "context": "Create a structured logging utility for the Countable backend at backend/src/utils/logger.ts. The logger should wrap console methods with structured JSON output for production use. Export a 'logger' object with methods: info(message, meta?), warn(message, meta?), error(message, meta?), debug(message, meta?). Each method outputs a JSON line: { timestamp: ISO string, level: 'info'|'warn'|'error'|'debug', message: string, ...meta }. In development (NODE_ENV !== 'production'), use readable format instead of JSON. Export the logger as default export and also as named export { logger }.",
      "deliverables": {
        "code": [
          "backend/src/utils/logger.ts"
        ],
        "tests": []
      },
      "description": "Create structured JSON logger at backend/src/utils/logger.ts with info/warn/error/debug methods. ~35 lines.",
      "constraints": "NEW file only. No external dependencies (use console.log internally). Keep under 45 lines. Export as both default and named export."
    },
    {
      "id": "BE-172",
      "agent": "backend-core",
      "type": "feature",
      "priority": "medium",
      "status": "pending",
      "context": "Create a request ID middleware for the Countable backend at backend/src/middleware/request-id.ts. This middleware generates a unique request ID for each incoming request, attaches it to the request object, and includes it in the response headers. Implementation: (1) Generate ID using crypto.randomUUID() or a simple 'req-' + Date.now() + '-' + Math.random().toString(36).slice(2,8) pattern. (2) Check if x-request-id header already exists — if so, use that (for tracing through proxies). (3) Set req.requestId = id (extend Express Request type). (4) Set res.setHeader('x-request-id', id). (5) Call next(). Export as default middleware function. Also export the RequestWithId interface extending Express Request.",
      "deliverables": {
        "code": [
          "backend/src/middleware/request-id.ts"
        ],
        "tests": []
      },
      "description": "Create request ID middleware at backend/src/middleware/request-id.ts — generates/propagates unique request IDs. ~30 lines.",
      "constraints": "NEW file only. Use crypto.randomUUID() for ID generation. Respect existing x-request-id header. Keep under 40 lines."
    },
    {
      "id": "SDK-090",
      "agent": "backend-core",
      "type": "feature",
      "priority": "high",
      "status": "pending",
      "context": "Create a retry utility for the Countable TypeScript SDK at sdk/typescript/src/retry.ts. This utility wraps async operations with configurable retry logic for resilient API calls. Export a function: retryWithBackoff<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T>. RetryOptions interface: { maxRetries?: number (default 3), initialDelayMs?: number (default 200), maxDelayMs?: number (default 5000), retryableStatuses?: number[] (default [408, 429, 500, 502, 503, 504]) }. Implementation: (1) Try fn(). (2) If error has a 'status' property matching retryableStatuses, wait and retry. (3) Use exponential backoff: delay = min(initialDelayMs * 2^attempt, maxDelayMs) + random jitter (0-50ms). (4) After maxRetries, throw the last error. Export both the function and the RetryOptions interface.",
      "deliverables": {
        "code": [
          "sdk/typescript/src/retry.ts"
        ],
        "tests": []
      },
      "description": "Create retry utility with exponential backoff at sdk/typescript/src/retry.ts for resilient SDK API calls. ~45 lines.",
      "constraints": "NEW file only. No external dependencies. Exponential backoff with jitter. Keep under 55 lines. Export function and RetryOptions interface."
    },
    {
      "id": "SDK-091",
      "agent": "backend-core",
      "type": "feature",
      "priority": "high",
      "status": "pending",
      "context": "Create a pagination helper for the Countable TypeScript SDK at sdk/typescript/src/pagination.ts. This utility provides an async iterator interface for paginated API responses. Export: (1) PaginatedResponse<T> interface: { data: T[], total: number, page: number, pageSize: number, hasMore: boolean }. (2) paginate<T>(fetchPage: (page: number, pageSize: number) => Promise<PaginatedResponse<T>>, options?: { pageSize?: number }): AsyncGenerator<T[], void, unknown>. The generator yields each page's data array, automatically fetching next pages until hasMore is false. Also export a collectAll<T>(generator: AsyncGenerator<T[]>) helper that collects all pages into a flat array. Default pageSize: 20.",
      "deliverables": {
        "code": [
          "sdk/typescript/src/pagination.ts"
        ],
        "tests": []
      },
      "description": "Create pagination helper with async generator at sdk/typescript/src/pagination.ts for paginated API responses. ~40 lines.",
      "constraints": "NEW file only. No external dependencies. Use AsyncGenerator for lazy page loading. Keep under 50 lines."
    },
    {
      "id": "FE-110",
      "agent": "frontend",
      "type": "feature",
      "priority": "high",
      "status": "pending",
      "context": "Create a reusable data table component for the Countable dashboard at frontend/components/ui/data-table.tsx. This is a generic table component used by invoices, settlements, API keys, and webhooks list pages. Props interface DataTableProps<T>: { columns: Array<{ key: keyof T, label: string, render?: (value: T[keyof T], row: T) => React.ReactNode }>, data: T[], loading?: boolean, emptyMessage?: string, onRowClick?: (row: T) => void }. Implementation: (1) Render a styled table with Tailwind (bg-white, rounded-lg, border). (2) Show LoadingSpinner from '../loading-spinner' when loading=true. (3) Show EmptyState from '../empty-state' when data is empty. (4) Map columns to <th> headers and data to <tr> rows. (5) Use render function if provided, otherwise display raw value. (6) Add hover effect on rows when onRowClick is provided. Export as named export.",
      "deliverables": {
        "code": [
          "frontend/components/ui/data-table.tsx"
        ],
        "tests": []
      },
      "description": "Create reusable DataTable<T> component at frontend/components/ui/data-table.tsx with columns, loading, empty states. ~55 lines.",
      "constraints": "NEW file only. Import LoadingSpinner and EmptyState from existing components (use relative '../loading-spinner' and '../empty-state'). Keep under 60 lines. Use TypeScript generics for type-safe columns."
    },
    {
      "id": "FE-111",
      "agent": "frontend",
      "type": "feature",
      "priority": "medium",
      "status": "pending",
      "context": "Create a confirmation dialog component for the Countable dashboard at frontend/components/ui/confirm-dialog.tsx. This reusable modal is used for destructive actions (delete API key, revoke webhook, etc.). Props interface ConfirmDialogProps: { open: boolean, onClose: () => void, onConfirm: () => void, title: string, message: string, confirmLabel?: string (default 'Confirm'), cancelLabel?: string (default 'Cancel'), variant?: 'danger' | 'warning' | 'info' (default 'danger') }. Implementation: (1) Render a centered modal overlay (fixed inset-0, bg-black/50, z-50). (2) Dialog box: bg-white, rounded-xl, p-6, max-w-md, mx-auto, mt-[20vh]. (3) Title as h3, message as p text-slate-600. (4) Two buttons: Cancel (outline) and Confirm (red bg for danger, amber for warning, blue for info). (5) Close on overlay click and Escape key. Use 'use client' directive.",
      "deliverables": {
        "code": [
          "frontend/components/ui/confirm-dialog.tsx"
        ],
        "tests": []
      },
      "description": "Create reusable ConfirmDialog component at frontend/components/ui/confirm-dialog.tsx with danger/warning/info variants. ~55 lines.",
      "constraints": "NEW file only. 'use client' directive required. Close on overlay click and Escape key. Keep under 60 lines."
    },
    {
      "id": "FE-112",
      "agent": "frontend",
      "type": "feature",
      "priority": "medium",
      "status": "pending",
      "context": "Create a page header component for the Countable dashboard at frontend/components/ui/page-header.tsx. This component provides a consistent header layout for all dashboard pages. Props interface PageHeaderProps: { title: string, description?: string, action?: { label: string, onClick: () => void, icon?: React.ReactNode } }. Implementation: (1) Wrapper div with flex justify-between items-center mb-6. (2) Left side: h1 text-2xl font-bold text-slate-900 for title, p text-sm text-slate-500 for description. (3) Right side: if action provided, render a button with bg-sky-600 text-white rounded-lg px-4 py-2 hover:bg-sky-700. (4) If action.icon provided, render it before the label. Use 'use client' directive.",
      "deliverables": {
        "code": [
          "frontend/components/ui/page-header.tsx"
        ],
        "tests": []
      },
      "description": "Create reusable PageHeader component at frontend/components/ui/page-header.tsx with title, description, and action button. ~35 lines.",
      "constraints": "NEW file only. 'use client' directive required. Keep under 40 lines. Simple layout component — no data fetching."
    },
    {
      "id": "SDK-092",
      "agent": "backend-core",
      "type": "feature",
      "priority": "medium",
      "status": "pending",
      "context": "Create a rate limit handler for the Countable TypeScript SDK at sdk/typescript/src/rate-limit.ts. This utility tracks API rate limits from response headers and provides wait-if-needed behavior. Export: (1) RateLimitInfo interface: { limit: number, remaining: number, resetAt: Date }. (2) RateLimitTracker class with methods: update(headers: Record<string, string>): void — parses x-ratelimit-limit, x-ratelimit-remaining, x-ratelimit-reset headers. getInfo(): RateLimitInfo | null. shouldWait(): boolean — returns true if remaining <= 0. getWaitMs(): number — returns ms until reset, or 0. waitIfNeeded(): Promise<void> — sleeps if rate limited. The class should handle missing headers gracefully (return null from getInfo). Export both the class and interface.",
      "deliverables": {
        "code": [
          "sdk/typescript/src/rate-limit.ts"
        ],
        "tests": []
      },
      "description": "Create rate limit tracking utility at sdk/typescript/src/rate-limit.ts — parses response headers, auto-waits when limited. ~50 lines.",
      "constraints": "NEW file only. No external dependencies. Parse standard rate limit headers. Keep under 55 lines."
    }
  ]
}
